/*
 * Auto-generated by Frida. Please modify to match the signature of remote_handle64_invoke.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: http://www.frida.re/docs/javascript-api/
 */

{
  /**
   * Called synchronously when about to call remote_handle64_invoke.
   *
   * @this {object} - Object allowing you to store state for use in onLeave.
   * @param {function} log - Call this function with a string to be presented to the user.
   * @param {array} args - Function arguments represented as an array of NativePointer objects.
   * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.
   * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
   * @param {object} state - Object allowing you to keep state across function calls.
   * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
   * However, do not use this to store function arguments across onEnter/onLeave, but instead
   * use "this" which is an object for keeping state local to an invocation.
   */


  onEnter: function (log, args, state) {

    function getRandNum(num) {
      return Math.floor(Math.random() * num + 1) ;
    }

    function getRandData(length) {
      var buffer = new ArrayBuffer(length);
      for (var i = 0; i < length; ++i) 
        buffer[i] = getRandNum(256);
      return buffer;
    }

    function produceData(pvlen, pv) {
      write_pos = getRandNum(pvlen);
      write_begin = parseInt(pv,16) + write_pos;
      write_len = Math.ceil((pvlen - write_pos) /getRandNum(10000));
      console.log("begin, len", write_pos, write_len);
      var data = Memory.readByteArray(ptr(parseInt(pv,16)), write_len);
    }

    function buf2hex(buffer) { 
      const byteArray = new Uint8Array(buffer);
      const hexParts = [];
      for(i = 0;  i < byteArray.length;i++) {
        const hex = byteArray[i].toString(16);
        const paddedHex = ('00' + hex).slice(-2);
        hexParts.push(paddedHex);
      }
      return hexParts;
    }
    log("FuncName: [a1]: " +  args[0] + " [a2]: " + args[1] + " [a3]: " + args[2]  );

    method_index = parseInt(args[1],16) >> 24
    in_num = (parseInt(args[1],16) >> 16) & 0xFF
    out_num = (parseInt(args[1],16) >> 8) & 0xFF
    console.log("\nmethod_index:" + method_index + ", innum: " + in_num + ", outnum: " + out_num + "\n");

    var data = Memory.readByteArray(ptr(args[2]), (in_num + out_num) * 16);
    invoke_args = buf2hex(data);
   

    for(line = 1; line < 2; line++) {
      begin = (line * 16)
      end = line * 16 + 8
      pv = invoke_args.slice(begin, end).reverse().join("");
      pvlen = invoke_args.slice(end, end + 8).reverse().join("");
      console.log("pvargs:", pv, pvlen, "\n");

      pvlen = parseInt(pvlen,16)
      //var data = Memory.readByteArray(ptr(parseInt(pv,16)), pvlen);
      
      //Memory.writeByteArray(ptr(parseInt(pv,16)), getRandData(4));
      //Memory.writeByteArray(ptr(parseInt(pv,16) + getRandNum(pvlen)),  getRandData(pvlen));
      write_pos = getRandNum(pvlen);
      write_begin = parseInt(pv,16) + write_pos;
      write_len = Math.ceil((pvlen - write_pos) /getRandNum(100));
      console.log("begin, len", write_pos, write_len);
      var data = Memory.readByteArray(ptr(parseInt(pv,16)), write_len);
      Memory.writeByteArray(ptr(write_begin),  data);

      write_pos = getRandNum(pvlen);
      write_begin = parseInt(pv,16) + write_pos;
      write_len = Math.ceil((pvlen - write_pos) /getRandNum(100));
      //console.log("begin, len", write_pos, write_len);
      //Memory.writeByteArray(ptr(write_begin),  getRandData(write_len));

      new_method = getRandNum(9);
      console.log("new_method, in, out", new_method, in_num, out_num);
      //args[1] = new_method << 24 + in_num << 16 + out_num << 8;
    }

  },

  /**
   * Called synchronously when about to return from remote_handle64_invoke.
   *
   * See onEnter for details.
   *
   * @this {object} - Object allowing you to access state stored in onEnter.
   * @param {function} log - Call this function with a string to be presented to the user.
   * @param {NativePointer} retval - Return value represented as a NativePointer object.
   * @param {object} state - Object allowing you to keep state across function calls.
   */
  onLeave: function (log, retval, state) {
    log("ret: " + retval);
  }
}
